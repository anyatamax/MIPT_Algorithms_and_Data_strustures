// Дана непустая строка S, длина которой N не превышает 106. Будем считать, что элементы строки нумеруются от 1 до N.
// Для каждой позиции i символа в строке нас будет интересовать подстрока, заканчивающаяся в этой позиции, и совпадающая с некоторым началом всей строки.
// Вообще говоря, таких подстрок будет несколько, не меньше двух. Самая длинная из них имеет длину i, она нас интересовать не будет. А будет нас интересовать самая длинная из остальных таких подстрок (заметим, что такая подстрока всегда существует — в крайнем случае, если ничего больше не найдется, сгодится пустая подстрока).
// Значением префикс-функции p[i] будем считать длину этой подстроки. Префикс-функция используется в различных алгоритмах обработки строк. В частности, с её помощью можно быстро решать задачу о поиске вхождения одной строки в другую («поиск образца в тексте»).
// Требуется для всех i от 1 до N вычислить p[i].

// Формат ввода
// Одна строка длины N, (1 ≤ N ≤ 10^6), состоящая из маленьких латинских букв.
// Формат вывода
// Выведите N чисел — значения префикс-функции для каждой позиции, разделенные пробелом. 


#include <iostream>
#include <vector>
#include <string>

std::vector<int> PrefixFunc(std::string& str) {
    std::vector<int> p(str.size(), 0);
    for (size_t i = 1; i < str.size(); ++i) {
        int k = p[i - 1];
        while (k > 0 && str[i] != str[k]) {
            k = p[k - 1];
        }
        if (str[i] == str[k]) {
            ++k;
        }
        p[i] = k;
    }
    return p;
}

int main() {
    std::string str;
    std::cin >> str;
    std::vector<int> prefix_mas = PrefixFunc(str);
    for (auto& i : prefix_mas) {
        std::cout << i << " ";
    }
    return 0;
}
