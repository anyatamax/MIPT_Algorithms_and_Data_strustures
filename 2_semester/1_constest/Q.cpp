

// Превышение скорости является опасным нарушением, значительно увеличивающим вероятность трагических последствий транспортных происшествий. К сожалению контроль скорости с использованием радаров и камер не решает проблему полностью. Притормаживая перед камерами, водители едут со значительным превышением на участках дорог, где контроль не ведётся. С целью предотвращения такого поведения используется назначение штрафа за гарантирование превышение скорости, основанное на времени проезда дороги.
// Рассмотрим дорогу, состоящую из n участков, пронумерованных от 1 до n. Длина i-го участка составляет li метров. На i-м из участков установлено ограничение по скорости в vi м/с.
// За превышение скорости предусмотрены штрафы. В зависимости от превышения, установлены различные штрафы, величина штрафа вычисляется следующим образом.
// Пусть e — максимальное превышение разрешённой скорости в процессе пребывания автомобиля на всей дороге, то есть максимальная разница между скоростью автомобиля и максимальной разре- шенной скоростью на участке, где он в этот момент находится. Если превышения скорости не было, то штраф не взимается. В противном случае штраф вычисляется так:
//     если 0 < e ≤ a1 то штраф составляет f1 денежных единиц;
//     если a1 < e ≤ a2, то штраф составляет f2 денежных единиц;
//     …
//     если am - 2 < e ≤ am - 1, то штраф составляет fm - 1 денежных единиц;
//     если am - 1 < e, то штраф составляет fm денежных единиц.
// Таким образом, есть m диапазонов превышения скорости и соответствующие им штрафы.
// Автоматическая система назначения штрафов получила данные о q автомобилях. Для удобства пронумеруем их от 1 до q. Известно, что i-й автомобиль заехал на дорогу в момент времени si, проехал все n участков, после чего выехал с нее в момент времени ti. Отсчёт времени будем вести в секундах с открытия дороги.
// Для каждого из автомобилей система должна определить, какой максимальный штраф можно гарантированно выписать этому автомобилю, основываясь только на времени заезда на дорогу и выезда с нее.
// Требуется написать программу, которая по описанию границ диапазонов превышения скорости, соответствующих штрафов и временам въезда/выезда автомобилей определяет для каждого автомобиля максимальный штраф, который можно выписать этому автомобилю.

// Формат ввода
// Первая строка входных данных содержит единственное целое число n (1 ≤ n ≤ 10) — количество участков на дороге.
// Вторая строка содержит n целых чисел vi (1 ≤ vi ≤ 10^9) — ограничения скорости на участках.
// Третья строка содержит n целых чисел li (1 ≤ li ≤ 10^9) — длины участков.
// Четвертая строка содержит единственное целое число m (1 ≤ m ≤ 10^5) — количество границ диапазонов превышения скорости.
// Пятая содержит m - 1 целых чисел ai (1 ≤ a 9 ≤ 10^9) — границы диапазонов превышения скорости. Гарантируется, что значения ai строго возрастают. Обратите внимание, что если m = 1, то пятая строка ввода пустая.
// Шестая строка содержит m целых чисел fi (1 ≤ fi ≤ 10^9) — штрафы за диапазоны превышения скоростей. Гарантируется, что значения fi возрастают.
// Седьмая строка содержит единственное целое число q (1 ≤ q ≤ 10^5) —количество автомобилей, которые надо обработать.
// Каждая из следующих q строк содержит два целых числа si и ti (1 ≤ s1 < ti ≤ 10^9) — время заезда на трассу и выезда с неё i-го из рассматриваемых автомобилей.

// Формат вывода
// Для каждого из q автомобилей выведите в отдельной строке максимальный штраф, который гарантированно можно выписать этому автомобилю, основываясь только на временах его заезда на дорогу и выезда с нее. Если возможна ситуация, что автомобиль ни разу не превысил разрешённую скорость, следует вывести 0.
// Гарантируется, что если время въезда или выезда автомобиля изменить не более чем на 10^(-5), штраф, который можно ему выписать, не изменится.

#include <iostream>
#include <vector>

bool IsCorrect(int overrun, std::vector<int> &l, std::vector<int> &v, int d) {
    double sum = 0;
    int length = l.size();
    for (size_t i = 0; i < length; i++) {
        sum += static_cast<double>(l[i]) / (static_cast<double>(v[i] + overrun));
    }
    return (static_cast<double>(d) <= sum);
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    std::cout.tie(NULL);
    int n, m, q, d, s, t;
    std::cin >> n;
    std::vector<int> v;
    for (size_t i = 0; i < n; i++) {
        int x;
        std::cin >> x;
        v.push_back(x);
    }
    std::vector<int> l;
    for (size_t i = 0; i < n; i++) {
        int x;
        std::cin >> x;
        l.push_back(x);
    }
    std::cin >> m;
    std::vector<int> a;
    a.push_back(0);
    for (size_t i = 0; i < m - 1; i++) {
        int x;
        std::cin >> x;
        a.push_back(x);
    }
    std::vector<int> f;
    for (size_t i = 0; i < m; i++) {
        int x;
        std::cin >> x;
        f.push_back(x);
    }
    std::cin >> q;
    for (size_t i = 0; i < q; i++) {
        std::cin >> s >> t;
        d = t - s;
        int left = 0;
        int right = m;
        while (right - left != 1) {
            int mid = (left + right) / 2;
            if (IsCorrect(a[mid], l, v, d)) {
                left = mid;
            } else {
                right = mid;
            }
        }
        if (!IsCorrect(a[0], l, v, d)) {
            std::cout << 0 << "\n";
        } else {
            std::cout << f[left] << "\n";
        }
    }
    return 0;
}
