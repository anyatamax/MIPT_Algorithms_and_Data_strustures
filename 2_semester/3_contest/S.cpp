// Вы на грани вылета из института.
// И неудивительно; на английский вы не ходили, по курсу алгоритмов вы не захотели получать трояк и пошли на пересдачу, на которую не пришли, так как вместо этого пошли с другом гамать. Еще вы не ходили на физру, а впереди матан, матлог и экзамен по ООП.
// Возможно, к кафедре иностранных языков вы найдете подход. Там есть активно посещаемый сайт, цель которого — выкладывать очередное огромное домашнее задание. И сайт этот в последнее время жутко тормозит, так как слишком много пользователей пишут тесты онлайн. Кафедра вам сказала, что если вы «ускорите работу сайта», то, возможно, вам пойдут навстречу.
// После некоторого изучения кода вы поняли, что слишком часто происходят обращения к базе данных, а именно, к таблице пользователей. Смысла в этом особого нет, поскольку набор посетителей сайта в каждый момент времени ограничен, и профили пользователей можно для быстрого доступа хранить в памяти, пока они осуществляют навигацию по сайту.
// Нужно просто написать кэширующую версию функции get_user(int user_id), которая возвращает профили пользователей, хранящиеся в базе данных.
// Логику кэширования Вы придумали следующую. Пусть размер кэша равен M. Тогда функция с кэшированием значений должна хранить список закэшированных профилей пользователей (будем профили пользователей называть просто пользователями). Размер списка не более M. Он конструируется по следующему принципу.
// Когда функция вызывается с некоторым аргументом user_id необходимо проверить, есть ли пользователь с таким идентификатором в списке, и если есть, вернуть закэшированный профиль, предварительно переместив его в самое начало списка. Если же такого пользователя нет, то нужно обратиться к базе данных и поместить пользователя в начало списка. Если размер списка стал больше M (а именно, M + 1), необходимо удалить из него последний элемент.
// Таким образом, в списке всегда будут храниться закэшированные ответы для последних M использованных уникальных значений аргумента функции. Вы хотите изучить, как меняется польза от кэширования в зависимости от значения M на последовательности реальных данных. Для решения этой задачи используйте ассоциативный контейнер и очередь с приоритетами.

// Формат ввода
// Первая строка входа содержит целое число M (0 < M < 5 ⋅ 10^5) — размер кэша. Затем идёт последовательность целых чисел из диапазона [0, 2 ⋅ 10^7], разделённых пробельными символами. Количество чисел не больше 5 ⋅ 10^5.
// Формат вывода
// Для каждого введённого числа необходимо вывести 0, если использовалось закэшированное значение, а иначе 1. Другими словами, для каждого введенного числа нужно выводить 1, если среди последних M уникальных чисел его нет, а иначе вывести 0. Цифры разделяйте пробелом. 


#include <iostream>
#include <algorithm>
#include <list>
#include <unordered_map>


int main () {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    int size, num;
    std::list<int> users_id;
    std::cin >> size;
    std::unordered_map<int, std::list<int>::iterator> map_users;
    while (std::cin >> num) {
        auto user = map_users.find(num);
        if (user != map_users.end()) {
            std::cout << 0 << " ";
            users_id.erase(user->second);
            users_id.push_front(num);
            map_users[num] = users_id.begin();
        } else {
            std::cout << 1 << " ";
            users_id.push_front(num);
            map_users[num] = users_id.begin();
            if (users_id.size() > size) {
                map_users.erase(users_id.back());
                users_id.pop_back();
            }
        }
    }
    return 0;
}
